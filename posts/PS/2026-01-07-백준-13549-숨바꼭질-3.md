# 13549 - 숨바꼭질 3

이 문제는 두 숫자 N과 K가 주어지고, 이동 방법을 이용해 N을 K로 만드는데 드는 최소 비용(문제에서는 시간)이 얼마인지 구해야 하는 문제이다. 이동 방법에는 두 가지가 있다.

- x+1 또는 x-1로 이동 (비용 1)
- 2*x로 이동 (비용 0)

숫자를 노드로 정의하고 비용을 간선의 가중치로 보면 이 문제가 그래프에서 최소 이동거리를 구하는 문제임을 알 수 있다. 가중치가 모든 간선마다 다르기 때문에 다익스트라 알고리즘을 쓰거나 0-1 BFS를 사용하면 이 문제를 풀 수 있다.

## 코드



## 전체 코드
### 다익스트라
```java
import java.util.*;
import java.io.*;


class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    static final int INF = 100005;
    static final int[] costs = {1,1,0};
    static class State {
        public int dist;
        public int num;

        public State(int dist, int num) {
            this.dist = dist;
            this.num = num;
        }
    }

    public static void main(String[] args) throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        if (N == K) {
            bw.write(0 + "\n");
            bw.flush();
            return;
        }
        else if (N > K) {
            bw.write(N - K + "\n");
            bw.flush();
            return;
        }

        int[] distances = new int[Math.max(N, K) + 5];
        Arrays.fill(distances, INF);

        PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingLong(e->e.dist));
        distances[N] = 0;
        pq.offer(new State(0, N));

        while (!pq.isEmpty()) {
            State s = pq.poll();
            if (s.dist > distances[s.num]) continue;
            if (s.num == K) break;
            int[] adjs = {s.num-1, s.num+1, 2*s.num};
            for (int i = 0; i < 3; i++) {
                int adjNum = adjs[i];
                int adjCost = costs[i];
                if (adjNum > Math.max(K, N) + 2 || adjNum < 0) continue;

                int newDist = s.dist + adjCost;
                if (newDist < distances[adjNum]) {
                    distances[adjNum] = newDist;
                    pq.offer(new State(newDist, adjNum));
                }
            }   
        }

        bw.write(distances[K] + "\n");
        bw.flush();
    }
}
```

### 0-1 BFS
```java
import java.util.*;
import java.io.*;


class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    static final int[] costs = {1,1,0};
    static final int INF = 100005;

    public static void main(String[] args) throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());


        if (N == K) {
            bw.write(0 + "\n");
            bw.flush();
            return;
        }
        else if (N > K) {
            bw.write(N - K + "\n");
            bw.flush();
            return;
        }

        int[] distances = new int[Math.max(N, K)+5];
        Arrays.fill(distances, INF);
        Deque<Integer> q = new ArrayDeque<>();
        q.addLast(N);
        distances[N] = 0;

        while (!q.isEmpty()) {
            int s = q.pop();
            if (s == K) break;
            int[] adjs = {s+1, s-1, 2*s};
            for (int i = 0; i < 3; i++) {
                int adjNum = adjs[i];
                int adjCost = costs[i];
                if (adjNum > Math.max(K, N) + 2 || adjNum < 0) continue;
                
                if (distances[s] + adjCost < distances[adjNum]) {
                    distances[adjNum] = distances[s] + adjCost;
                    if (adjCost == 1) 
                        q.addLast(adjNum);
                    else
                        q.addFirst(adjNum);
                }
                
            }   
        }

        bw.write(distances[K] + "\n");
        bw.flush();
    }
}
```

## 시간복잡도
# 16953 - A → B

이 문제는 시작점 A에서 끝점 B로 가는 최소 연산 수를 구해야 하는 문제이다. 이때 2를 곱하는 연산과 1을 수의 가장 오른쪽에 추가하는 두 가지 연산이 가능하다. 

이 문제의 특징은 어떠한 수로 가는 경로(연산의 나열)은 반드시 하나밖에 없다는 것이다. A에서 한 번 이상의 연산을 통해 생성한 어떠한 수 N을 가정하자. N은 2x이거나 10y+1 로 나타낼 수 있다. (x, y는 직전 단계의 자연수이다.) 그런데 만약 N = 2x라면 10y+1로 나타낼 수 없고, N = 10y+1이라면 2x로 나타낼 수 없다. 즉 연산 한 번을 이용해 어떠한 수 N으로 도달할 수 있는 수는 오직 하나이다. 이 사실은 A에서 한 번 이상 연산을 적용한 모든 수에 대해 성립하므로 A에서 연산의 반복을 통해 N을 만들 수 있는 경로는 오직 하나임을 알 수 있다.

따라서 

## 코드

## 전체 코드

### BFS로 푼 경우

```java
import java.util.*;
import java.io.*;

class Node {
    public long val;
    public int cnt;

    public Node(long val, int cnt) {
        this.cnt = cnt;
        this.val = val;
    }
}

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    public static void main(String[] args) throws IOException {
        StringTokenizer s = new StringTokenizer(br.readLine());
        long a = Long.parseLong(s.nextToken());
        long b = Long.parseLong(s.nextToken());

        Deque<Node> queue = new ArrayDeque<>();
        queue.addLast(new Node(a, 1));

        int result = -1;
        while (!queue.isEmpty()) {
            Node node = queue.pop();
            if (node.val == b) {
                result = node.cnt;
                break;
            }
            List<Long> adjs = List.of(node.val * 2, node.val * 10 + 1);
            for (long adj : adjs) {                
                if (adj > b) continue;
                queue.addLast(new Node(adj, node.cnt + 1));
            }
        }
    
        bw.write(result + "\n");
        bw.flush();
    }
}

```

### 그리디로 푼 경우

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    public static void main(String[] args) throws IOException {
        StringTokenizer s = new StringTokenizer(br.readLine());
        long a = Long.parseLong(s.nextToken());
        long b = Long.parseLong(s.nextToken());

        int cnt = 0;
        long cur = b;

        while (true) {
            if (cur == a) 
                break;

            if (cur % 2 == 0 && cur / 2 >= a) {
                cur /= 2;
            }
            else if (cur % 10 == 1 && cur / 10 >= a) {
                cur /= 10;
            }
            else {
                bw.write(-1 + "\n");
                bw.flush();
                return;
            }
            cnt++;
        }
        
        bw.write((cnt+1) + "\n");
        bw.flush();
    }
}

```
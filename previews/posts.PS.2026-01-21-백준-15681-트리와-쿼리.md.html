
      <html lang="ko">
      <head>
        <title>15681 - íŠ¸ë¦¬ì™€ ì¿¼ë¦¬</title>
        <link rel="canonical" href="http://yuyeol3.github.io/"/>
        <meta charset="utf-8"/>
        <meta name="description" content="ì´ ë¬¸ì œëŠ” ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” íŠ¸ë¦¬(ë£¨íŠ¸ í¬í•¨)ê°€ ì£¼ì–´ì§ˆ ë•Œ, ì •ì  Uë¥¼ ë£¨íŠ¸ë¡œ í•˜ëŠ” ì„œë¸Œ íŠ¸ë¦¬(ë¶€ë¶„ íŠ¸ë¦¬)ì— ì†í•œ ì •ì ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.">
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      </head>
      <body style="display : none;">
        
        <h1>15681 - íŠ¸ë¦¬ì™€ ì¿¼ë¦¬</h1>
<p>ì´ ë¬¸ì œëŠ” ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” íŠ¸ë¦¬(ë£¨íŠ¸ í¬í•¨)ê°€ ì£¼ì–´ì§ˆ ë•Œ, ì •ì  Uë¥¼ ë£¨íŠ¸ë¡œ í•˜ëŠ” ì„œë¸Œ íŠ¸ë¦¬(ë¶€ë¶„ íŠ¸ë¦¬)ì— ì†í•œ ì •ì ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. </p>
<p>ê°€ì¥ ê°„ë‹¨í•˜ê²Œ ìƒê°í•´ ë³¼ ìˆ˜ ìˆëŠ” í’€ì´ ë°©ë²•ì€ recursive DFSë¥¼ ì´ìš©í•˜ëŠ” ê²ƒì´ë‹¤. <code>int dfs(node)</code> í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì—¬ nodeë¥¼ ì‹œì‘ì ìœ¼ë¡œ dfsë¥¼ ìˆ˜í–‰í•˜ë©° ì°¾ì€ ëª¨ë“  ë…¸ë“œì˜ ê°œìˆ˜ë¥¼ ë°˜í™˜í•˜ë„ë¡ í•œë‹¤. ë˜í•œ ê²°ê³¼ë¥¼ <code>dp[node]</code>ì— ì €ì¥í•˜ì—¬ ì¶”í›„ ì¿¼ë¦¬ ì‹œ $O(1)$ë¡œ ë‹µì„ ì°¾ì„ ìˆ˜ ìˆë„ë¡ í•œë‹¤. ì´ êµ¬í˜„ ë°©ë²•ì€ ì¬ê·€í•¨ìˆ˜ì˜ íŠ¹ì§•ì„ ì´ìš©í•´ ë¦¬í”„ ë…¸ë“œë¶€í„° ë£¨íŠ¸ ë…¸ë“œê¹Œì§€ ìˆœì„œëŒ€ë¡œ ë…¸ë“œ ê°œìˆ˜ë¥¼ ê³„ì‚°í•˜ì—¬ ë”í•˜ëŠ” ê²ƒìœ¼ë¡œ êµ¬í˜„ì´ ê°„ë‹¨í•œ ì¥ì ì´ ìˆë‹¤. ë°˜ë©´ íŠ¸ë¦¬ ë†’ì´ê°€ ë„ˆë¬´ ë†’ì•„ì„œ ì¬ê·€ í•¨ìˆ˜ê°€ ìŠ¤íƒ í”„ë ˆì„ì— ë„ˆë¬´ ë§ì´ ìŒ“ì¼ ê²½ìš° ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤ëŠ” ì ì€ ê³ ë ¤í•´ì•¼ í•œë‹¤. ì´ ë¬¸ì œì˜ ê²½ìš°ì—ëŠ” recursive DFSë¡œë„ í†µê³¼í•  ìˆ˜ ìˆì—ˆë‹¤. </p>
<p>ë§Œì•½ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ë‚˜ ì½”ë“œ ì„±ëŠ¥ì„ ìš°ë ¤í•œë‹¤ë©´ iterative DFSë¡œë„ í’€ ìˆ˜ ìˆë‹¤. ë¨¼ì € DFSë¥¼ í†µí•´ ë£¨íŠ¸ ë…¸ë“œë¶€í„° ì‹œì‘í•˜ëŠ” íŠ¸ë¦¬ì˜ ìˆœíšŒ ìˆœì„œì™€ ê° ë…¸ë“œë³„ ë¶€ëª¨ ë…¸ë“œë¥¼ ê¸°ë¡í•œë‹¤. ê·¸ëŸ° ë‹¤ìŒ, ê¸°ë¡ëœ íŠ¸ë¦¬ ìˆœíšŒ ìˆœì„œì˜ ì—­ìˆœìœ¼ë¡œ ëŒë©´ì„œ ìì‹ ì˜ ë¶€ëª¨ ë…¸ë“œì˜ dp ì›ì†Œì— ìì‹ ì˜ dp ì›ì†Œë¥¼ ë”í•´ì¤€ë‹¤. ì´ ê³¼ì •ì„ ì™„ë£Œí•˜ë©´ dp ë°°ì—´ì— ìµœì¢…ì ì¸ ì„œë¸Œ íŠ¸ë¦¬ì˜ ì›ì†Œ ê°œìˆ˜ê°€ êµ¬í•´ì§„ë‹¤.</p>
<p>ë‘ ë°©ì‹ ëª¨ë‘ dpì˜ ì •ì˜ì™€ ì í™”ì‹ ìì²´ëŠ” ë™ì¼í•˜ë‹¤. <code>dp[i]</code>ë¥¼ ìê¸° ìì‹ ì„ ë£¨íŠ¸ë¡œ í•˜ëŠ” ì„œë¸Œ íŠ¸ë¦¬ì˜ ì •ì  ê°œìˆ˜ë¡œ ì •ì˜í•˜ë©´ ì í™”ì‹ì€ ì•„ë˜ì™€ ê°™ë‹¤.</p>
<p>$$</p>
<p>dp[i] = 1 + \sum_{v \ \in \ \text{children}[i]} dp[v]
$$</p>
<p>1ì„ ë”í•˜ëŠ” ì´ìœ ëŠ” ìê¸° ìì‹ ì„ ì •ì  ê°œìˆ˜ë¡œ í¬í•¨í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤. </p>
<p><a href="https://www.acmicpc.net/problem/15681">ğŸ”— ë¬¸ì œ ë§í¬</a></p>
<h2>ì½”ë“œ</h2>
<h3>ì¬ê·€ë¡œ í’€ ê²½ìš°</h3>
<p>ë¨¼ì € ì •ì ì˜ ê°œìˆ˜ N, ë£¨íŠ¸ ë…¸ë“œì˜ ë²ˆí˜¸ R, ì§ˆì˜ì˜ ê°œìˆ˜ Që¥¼ ì…ë ¥ë°›ëŠ”ë‹¤. </p>
<pre><code class="language-java">public static void main(String[] args) throws IOException {
    StringTokenizer st = new StringTokenizer(br.readLine());

    int N, R, Q;
    N = Integer.parseInt(st.nextToken());
    R = Integer.parseInt(st.nextToken());
    Q = Integer.parseInt(st.nextToken());
</code></pre>
<p>ë‹¤ìŒìœ¼ë¡œ ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°ì„ ìœ„í•œ <code>dp</code>ë°°ì—´ê³¼ ë…¸ë“œ ë°©ë¬¸ ì²´í¬ë¥¼ ìœ„í•œ <code>visited</code> ë°°ì—´ì„ ì„ ì–¸í•œë‹¤. ë˜í•œ íŠ¸ë¦¬ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ ì¸ì ‘ ë°°ì—´ í˜•íƒœë¡œ ì„ ì–¸í•˜ê³  <code>ArrayList</code>ë¡œ ì´ˆê¸°í™”í•´ ì¤€ë‹¤.</p>
<pre><code class="language-java">    dp = new int[N+1];
    visited = new boolean[N+1];

    @SuppressWarnings(&quot;unchecked&quot;)
    List&lt;Integer&gt;[] tree = new List[N+1];

    for (int i = 0; i &lt;= N; i++) 
        tree[i] = new ArrayList&lt;&gt;();
</code></pre>
<p>ë‹¤ìŒìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤.</p>
<pre><code class="language-java">    for (int i = 0; i &lt; N-1; i++) {
        st = new StringTokenizer(br.readLine());
        int a = Integer.parseInt(st.nextToken());
        int b = Integer.parseInt(st.nextToken());

        tree[a].add(b);
        tree[b].add(a);
    }
</code></pre>
<p>ì´ì œ ì´ ì½”ë“œì—ì„œ í•µì‹¬ ë¡œì§ì¸ dfsë¥¼ ìˆ˜í–‰í•œë‹¤. ì•ì„œ ì„¤ëª…í–ˆë“¯ dfs í•¨ìˆ˜ëŠ” íŠ¸ë¦¬ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ìˆœíšŒí•˜ë©° ë¦¬í”„ ë…¸ë“œë¶€í„° ë£¨íŠ¸ ë…¸ë“œê¹Œì§€ì˜ ë…¸ë“œ ê°œìˆ˜ë¥¼ êµ¬í•˜ê²Œ ëœë‹¤. ë˜í•œ ê° ë…¸ë“œë§ˆë‹¤, ê·¸ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ í•˜ì˜€ì„ ë•Œ ì„œë¸Œ íŠ¸ë¦¬ê°€ ê°€ì§„ ì •ì ì˜ ê°œìˆ˜ë¥¼ dpì— ì €ì¥í•œë‹¤.</p>
<pre><code class="language-java">    dfs(R, tree);
    // ...


public static int dfs(int node, final List&lt;Integer&gt;[] tree) {
    visited[node] = true;
    
    int tot = 1;
    for (int adj : tree[node]) {
        if (visited[adj]) continue;
        tot += dfs(adj, tree);
    }
    dp[node] = tot;
    return tot;
}

</code></pre>
<p>dfsë¥¼ í†µí•œ íŠ¸ë¦¬ ìˆœíšŒë¥¼ ì™„ë£Œí•˜ë©´ ì¿¼ë¦¬ë¥¼ ì…ë ¥ë°›ì•„ dpë°°ì—´ì— ìˆëŠ” ê°’ì„ ê°€ì ¸ì˜¨ ë’¤ ì¶œë ¥í•œë‹¤. ë‹µë³€ì„ ëª¨ë‘ ì¶œë ¥í•˜ë©´ í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•œë‹¤.</p>
<pre><code class="language-java">    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; Q; i++) {
        int q = Integer.parseInt(br.readLine());
        sb.append(dp[q]).append(&quot;\n&quot;);
    }
    System.out.print(sb);
}
</code></pre>
<h3>ë°˜ë³µë¬¸ìœ¼ë¡œ í’€ ê²½ìš°</h3>
<p>ì…ë ¥ ì½”ë“œëŠ” ì´ì „ê³¼ ë¹„ìŠ·í•˜ë¯€ë¡œ ë‹¬ë¼ì§„ ë¶€ë¶„ ìœ„ì£¼ë¡œ ì‚´í´ë³´ì.</p>
<p>ê¸°ì¡´ì— ì„ ì–¸í–ˆë˜ ë³€ìˆ˜ ì´ì™¸ì— <code>parent</code>ì™€ <code>traverse</code> ë°°ì—´ì„ ì¶”ê°€ë¡œ ì„ ì–¸í•˜ì˜€ë‹¤. <code>parent</code> ë°°ì—´ì—ëŠ” ì–´ë–¤ ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œê°€ ë¬´ì—‡ì¸ì§€ ì €ì¥í•´ë‘”ë‹¤. traverseì—ëŠ” DFSì˜ ë°©ë¬¸ ìˆœì„œë¥¼ ì €ì¥í•´ë‘”ë‹¤.</p>
<pre><code class="language-java">    int[] parent = new int[N+1];
    int[] traverse = new int[N];
    int tIdx = 0;
</code></pre>
<p>DFSë¥¼ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ dqë¥¼ ì„ ì–¸í•œë‹¤. ë£¨íŠ¸ ë…¸ë“œì¸ Rì„ ì‚½ì…í•˜ê³  ë°©ë¬¸ì²˜ë¦¬ë„ í•´ ì¤€ë‹¤. ì´í›„ ë°˜ë³µë¬¸ì„ ëŒë©° DFSë¥¼ ìˆ˜í–‰í•œë‹¤.</p>
<p>ìŠ¤íƒì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚¸ ë’¤ <code>traverse[tIdx++] = node</code>ë¥¼ ìˆ˜í–‰í•œë‹¤. ì¦‰ ë°©ë¬¸ ìˆœì„œë¥¼ traverseì— ì €ì¥í•œë‹¤. ë‹¤ìŒìœ¼ë¡œ ì¸ì ‘ ë…¸ë“œë“¤ì— ëŒ€í•´ <code>parent[adj] = node</code>ë¡œ ì¸ì ‘ ë…¸ë“œì˜ ë¶€ëª¨ë¥¼ ì§€ì •í•´ì¤€ë‹¤. ë‹¤ìŒìœ¼ë¡œ ë°©ë¬¸ ì²˜ë¦¬ í›„ ìŠ¤íƒì— ë„£ëŠ”ë‹¤. </p>
<pre><code class="language-java">    Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();
    dq.addFirst(R);
    visited[R] = true;

    while (!dq.isEmpty()) {
        int node = dq.pollFirst();
        traverse[tIdx++] = node;
        for (int adj : tree[node]) {
            if (visited[adj]) continue;
            parent[adj] = node;
            visited[adj] = true;
            dq.addFirst(adj);
        }
    }
</code></pre>
<p>ë‹¤ìŒìœ¼ë¡œ dp ë°°ì—´ì„ ì í™”ì‹ì„ ì´ìš©í•´ ê³„ì‚°í•´ì¤€ë‹¤. ë¨¼ì € ëª¨ë“  dp ë°°ì—´ì˜ ì›ì†Œë¥¼ 1ë¡œ ì±„ì›Œì¤€ë‹¤. ì™œëƒí•˜ë©´ ëª¨ë“  ì„œë¸Œ íŠ¸ë¦¬ì˜ ë…¸ë“œ ê°œìˆ˜ëŠ” ìµœì†Œ 1ê°œì´ê¸° ë•Œë¬¸ì´ë‹¤. </p>
<p>ë‹¤ìŒìœ¼ë¡œ N-1ë¶€í„° 1ê¹Œì§€ ë°˜ë³µë¬¸ì„ ëŒë©° ì í™”ì‹ì„ ê³„ì‚°í•´ì¤€ë‹¤. DFSì—ì„œ ìˆœíšŒí•œ ìˆœì„œì˜ ì—­ìˆœìœ¼ë¡œ ë…¸ë“œë¥¼ ê³¨ë¼ ê·¸ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ í•˜ëŠ” ì„œë¸Œ íŠ¸ë¦¬ì˜ ë…¸ë“œ ê°œìˆ˜ë¥¼(<code>=dp[traverse[i]]</code>) ì„ íƒí•œ ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ í•˜ëŠ” ì„œë¸Œ íŠ¸ë¦¬ì˜ ë…¸ë“œ ê°œìˆ˜ì— ë”í•´ì¤€ë‹¤(<code>=dp[parent[traverse[i]]]</code>)</p>
<p><code>traverse</code>ì—ëŠ” ë¶€ëª¨ê°€ ìì‹ë³´ë‹¤ ë¨¼ì € ë“¤ì–´ê°€ë¯€ë¡œ(ì „ìœ„ ìˆœíšŒ), ì´ë¥¼ ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ë©´ í•­ìƒ ìì‹ì˜ dpê°€ ë¨¼ì € í™•ì •ë˜ê³  ê·¸ ê°’ì„ ë¶€ëª¨ì— ëˆ„ì í•  ìˆ˜ ìˆë‹¤.</p>
<pre><code class="language-java">    Arrays.fill(dp, 1);

    for (int i = N-1; i &gt; 0; i--) {
        dp[parent[traverse[i]]] += (dp[traverse[i]]);
    }
</code></pre>
<p>ì´í›„ ì¿¼ë¦¬ë¥¼ ì…ë ¥ë°›ì•„ ì •ë‹µì„ ì¶œë ¥í•˜ëŠ” ì½”ë“œëŠ” ì´ì „ê³¼ ê°™ì•„ ìƒëµí•˜ì˜€ë‹¤.</p>
<h2>ì „ì²´ ì½”ë“œ</h2>
<h3>ì¬ê·€ë¡œ í’€ ê²½ìš°</h3>
<pre><code class="language-java">import java.util.*;
import java.io.*;

class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int[] dp;
    static boolean[] visited;
    public static void main(String[] args) throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N, R, Q;
        N = Integer.parseInt(st.nextToken());
        R = Integer.parseInt(st.nextToken());
        Q = Integer.parseInt(st.nextToken());

        dp = new int[N+1];
        visited = new boolean[N+1];

        @SuppressWarnings(&quot;unchecked&quot;)
        List&lt;Integer&gt;[] tree = new List[N+1];

        for (int i = 0; i &lt;= N; i++) 
            tree[i] = new ArrayList&lt;&gt;();


        for (int i = 0; i &lt; N-1; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());

            tree[a].add(b);
            tree[b].add(a);
        }

        dfs(R, tree);

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; Q; i++) {
            int q = Integer.parseInt(br.readLine());
            sb.append(dp[q]).append(&quot;\n&quot;);
        }
        System.out.print(sb);
    }

    public static int dfs(int node, final List&lt;Integer&gt;[] tree) {
        visited[node] = true;
        
        int tot = 1;
        for (int adj : tree[node]) {
            if (visited[adj]) continue;
            tot += dfs(adj, tree);
        }
        dp[node] = tot;
        return tot;
    }
}
</code></pre>
<h3>ë°˜ë³µë¬¸ìœ¼ë¡œ í’€ ê²½ìš°</h3>
<pre><code class="language-java">import java.util.*;
import java.io.*;

class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int[] dp;
    static boolean[] visited;
    public static void main(String[] args) throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N, R, Q;
        N = Integer.parseInt(st.nextToken());
        R = Integer.parseInt(st.nextToken());
        Q = Integer.parseInt(st.nextToken());

        dp = new int[N+1];
        visited = new boolean[N+1];

        @SuppressWarnings(&quot;unchecked&quot;)
        List&lt;Integer&gt;[] tree = new List[N+1];

        for (int i = 0; i &lt;= N; i++)  
            tree[i] = new ArrayList&lt;&gt;();


        for (int i = 0; i &lt; N-1; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());

            tree[a].add(b);
            tree[b].add(a);
        }

        int[] parent = new int[N+1];
        int[] traverse = new int[N];
        int tIdx = 0;

        Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();
        dq.addFirst(R);
        visited[R] = true;

        while (!dq.isEmpty()) {
            int node = dq.pollFirst();
            traverse[tIdx++] = node;
            for (int adj : tree[node]) {
                if (visited[adj]) continue;
                parent[adj] = node;
                visited[adj] = true;
                dq.addFirst(adj);
            }
        }

        Arrays.fill(dp, 1);

        for (int i = N-1; i &gt; 0; i--) {
            dp[parent[traverse[i]]] += (dp[traverse[i]]);
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; Q; i++) {
            int q = Integer.parseInt(br.readLine());
            sb.append(dp[q]).append(&quot;\n&quot;);
        }
        System.out.print(sb);
    }
}
</code></pre>
<h2>ì‹œê°„ë³µì¡ë„</h2>
<p>ì¬ê·€ì˜ ê²½ìš° dfsë¥¼ í†µí•´ íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ë™ì‹œì— dpì— ê°’ì„ ê³„ì‚°í•´ ì €ì¥í•œ ë’¤, ì§ˆì˜ì— ëŒ€í•œ ë‹µì„ dpì—ì„œ êº¼ë‚´ ì¶œë ¥í•œë‹¤. ë…¸ë“œ ê°œìˆ˜ê°€ Nì´ë¯€ë¡œ dfsì˜ ì‹œê°„ë³µì¡ë„ëŠ” $O(N)$ì´ê³ , ì¿¼ë¦¬ ê°œìˆ˜ë§Œí¼ ë‹µë³€ì„ êº¼ë‚´ì˜¤ëŠ” ì‹œê°„ë³µì¡ë„ëŠ” $O(Q)$ ì´ë‹¤. ë”°ë¼ì„œ ìµœì¢… ì‹œê°„ë³µì¡ë„ëŠ” $O(N+Q)$ ì´ë‹¤.</p>
<p>ë°˜ë³µë¬¸ì˜ ê²½ìš° dfsì— $O(N)$, ì í™”ì‹ì„ í†µí•œ dp ê³„ì‚°ì— $O(N)$, ì¿¼ë¦¬ì— ë”°ë¥¸ ë‹µë³€ì— $O(Q)$ì˜ ì‹œê°„ì´ ê±¸ë¦¬ë¯€ë¡œ $O(2N+Q) \approx O(N+Q)$ ì´ë‹¤.</p>
<p>ìµœì•…ì˜ ê²½ìš°ì—ë„ $2\times 10^5 \lt 1\text{ì–µ}$ ì´ë¯€ë¡œ 1ì´ˆ ë‚´ì— í†µê³¼í•  ìˆ˜ ìˆë‹¤.</p>

        <script>
          location.href = "/post-view?href=posts%2FPS%2F2026-01-21-%EB%B0%B1%EC%A4%80-15681-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%BF%BC%EB%A6%AC.md"
        </script>
      </body>
  
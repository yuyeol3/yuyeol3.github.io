
      <html lang="ko">
      <head>
        <title>DFS, BFS</title>
        <link rel="canonical" href="http://yuyeol3.github.io/"/>
        <meta charset="utf-8"/>
        <meta name="description" content="DFS와 BFS는 모두 그래프를 탐색하기 위한 방법이다. 즉, 그래프를 탐색하기 위해 DFS나 BFS를 모두 사용할 수 있지만 탐색할 다음 노드를 결정할 때 두 방식의 동작이 다르다. 이 때문에 사용하는 방법에도 차이가 있다.">
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      </head>
      <body style="display : none;">
        
        <h1>DFS, BFS</h1>
<p>DFS와 BFS는 모두 그래프를 탐색하기 위한 방법이다. 즉, 그래프를 탐색하기 위해 DFS나 BFS를 모두 사용할 수 있지만 탐색할 다음 노드를 결정할 때 두 방식의 동작이 다르다. 이 때문에 사용하는 방법에도 차이가 있다.</p>
<h2>그래프</h2>
<p>node, vertex weight (가중치)</p>
<h3>그래프의 컴퓨터 표현</h3>
<ul>
<li>그냥 edge(간선) 만 저장<ul>
<li>간선 정보만 저장하면, 노드와 노드 간 인접 정보를 알기 어려운 단점</li>
</ul>
</li>
<li>인접 행렬<ul>
<li>공간복잡도가 O(N^2) 인 단점</li>
<li>특정 노드 두 개의 연결 여부는 매우 빠르게 확인 가능</li>
</ul>
</li>
<li>인접 리스트<ul>
<li>공간복잡도 : O(sum(adjacent_nodes))</li>
</ul>
</li>
</ul>
<pre><code class="language-python">edge = [[] for i in range(n+1)]

for i in range(m):
	a, b = map(int, input().split())

	edge[a].append(b)
	edge[b].append(a)
</code></pre>
<pre><code class="language-python">1 : [2, 3]
2 : [1, 3]
3 : [1, 2]
4 : [5]
5 : [4]
</code></pre>
<p>세 표현 방식은 한 그래프에 대해 동치이며, 서로 전환할 수 있다.</p>
<h2>DFS</h2>
<pre><code class="language-python"># 방문처리
visited = [False for i in range(n)]
def dfs(cur):
	visited[cur] = True
	
	for i in range(len(edge)):
		nxt = edge[cur][i]
		if visited[nxt]: continue
		dfs(nxt)


dfs(1)
</code></pre>
<p>모두 다 방문되면 끝남
$\rightarrow$ 각 노드를 한 번씩만 방문하게 됨
visited 배열을 살펴보면, 연결 요소 간 관계를 알 수 있다.</p>
<p>백트래킹의 경우
$\rightarrow$ 모든 경로를 탐색하므로 visited를 해제함</p>
<h2>격자로 표현된 그래프와 DFS</h2>
<p>격자 한 칸을 노드, 갈 수 있는 방향을 간선으로 보면 격자 문제를 그래프 탐색으로 풀 수 있음</p>
<pre><code class="language-python">def dfs(x, y):
	visited[x][y] = True

	for i in range(2):
		nx = x + dx[i]
		ny = y + dy[i]

		if (nx &lt; 0 or nx &gt;= N or
			ny &lt; 0 or ny &gt;= M or 
			arr[nx][ny] == 1  or 
			visited[nx][ny]): 
			continue
		
		dfs(nx, ny)
</code></pre>
<h2>BFS 탐색</h2>
<ul>
<li>재귀 없이 짬</li>
<li>queue 사용</li>
<li>큐에 넣을 때 방문처리 해줘야 함</li>
</ul>
<pre><code class="language-python">
queue = deque()
visited = [False for i in range(n+1)]

queue.append(1)
visited[1] = True

while len(queue) &gt; 0:
	cur = queue[0]
	que.popleft()

	for nxt in edge[cur]:
		if visited[nxt]:
			continue

		queue.append(nxt)
		visited[nxt] = True
</code></pre>
<ul>
<li>BFS 특징<ul>
<li>시작점부터 거리 순으로 퍼져나감</li>
<li>따라서 이동거리 추적이 가능</li>
</ul>
</li>
</ul>
<pre><code class="language-python">
queue = deque()
visited = [False for i in range(n+1)]
dist = [-1 for i in range(n+1)]
queue.append(1)
visited[1] = True
dist[1] = 0
while len(queue) &gt; 0:
	cur = queue[0]
	que.popleft()

	for nxt in edge[cur]:
		if visited[nxt]:
			continue

		queue.append(nxt)
		dist[nxt] = dist[cur] + 1
		visited[nxt] = True
</code></pre>

        <script>
          location.href = "/post-view?href=posts/CS／알고리즘/2025-10-11-DFS,BFS.md"
        </script>
      </body>
  
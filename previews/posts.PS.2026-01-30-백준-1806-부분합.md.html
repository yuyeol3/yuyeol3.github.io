
      <html lang="ko">
      <head>
        <title>1806 - 부분합</title>
        <link rel="canonical" href="http://yuyeol3.github.io/"/>
        <meta charset="utf-8"/>
        <meta name="description" content="이 문제는 자연수 N개로 이루어진 수열이 주어졌을 때, S 이상을 만족하는 수열의 부분합 중 최소 길이를 찾아야 한다.">
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      </head>
      <body style="display : none;">
        
        <h1>1806 - 부분합</h1>
<p>이 문제는 자연수 N개로 이루어진 수열이 주어졌을 때, S 이상을 만족하는 수열의 부분합 중 최소 길이를 찾아야 한다.</p>
<p>문제를 어떻게 풀 수 있을까? 필자의 경우 가장 먼저 떠올린 방법은 누적합과 BST를 이용하는 방법이었다. 첫 원소부터 누적합을 구하면서, 구한 누적합을 트리에 넣는다. 그런 다음 각 누적합 원소마다 S 이상인지 확인한다. 만약 S 이상이라면 <code>누적합 원소 - S</code>보다 작거나 같은 누적합 원소 중 가장 큰 원소를 찾아 그 원소의 위치를 이용해 구간의 최소 크기를 계속 업데이트한다. 이러한 방식으로 문제를 풀면 $O(n \log n)$ 의 시간복잡도로 문제를 통과할 수 있다.</p>
<p>하지만 더 효율적인 방법이 있다. 이를 위해서는 이 문제에서 모든 수열의 원소가 &#39;자연수&#39;라는 조건에 주목해야 한다. 수열의 원소가 모두 자연수라면, 구간의 길이를 늘릴수록 합은 무조건 커지고(단조 증가), 줄일수록 합은 작아진다. 이 성질을 이용하면 굳이 지난 합을 기억할 필요 없이, 두 개의 포인터(l, u)를 조절하는 것만으로 $O(N)$ 만에 답을 구할 수 있다.</p>
<p><a href="https://boj.kr/1806">🔗 문제 링크</a></p>
<h2>코드</h2>
<p>필요한 변수를 선언한다. 구간합의 가능한 최대 길이보다 5 큰 값으로 초기화하였다. 이는 구간 길이의 최소값을 업데이트 할 때 필요하다.</p>
<pre><code class="language-java">static int MAX_LENGTH = 100005;
</code></pre>
<p>다음으로 main 메서드에서 <code>N</code>과 <code>S</code>값을 입력받는다. <code>N</code>은 수열의 길이이고, <code>S</code>는 앞서 말했듯 구간합 크기의 기준이다.</p>
<pre><code class="language-java">public static void main(String[] args) throws IOException {
    StringTokenizer st = new StringTokenizer(br.readLine());
    int N, S;
    N = Integer.parseInt(st.nextToken());
    S = Integer.parseInt(st.nextToken());
</code></pre>
<p>수열의 원소를 입력받으면서 즉시 누적합 계산을 하여 <code>prefixSum</code> 배열에 저장한다. 인덱싱은 1 based로 하였다. </p>
<pre><code class="language-java">    int[] prefixSum = new int[N+1];
    st = new StringTokenizer(br.readLine());
    for (int i = 1; i &lt;= N; i++) {
        prefixSum[i] = prefixSum[i-1] + Integer.parseInt(st.nextToken());
    }
</code></pre>
<p>이제 투 포인터 알고리즘을 수행한다. <code>l</code>은 왼쪽 포인터, <code>u</code>는 오른쪽 포인터를 나타낸다. <code>minLength</code>는 S보다 크거나 같은 조건을 만족하는 구간합의 길이의 최소값을 추적하기 위한 변수이다. 아까 언급했듯이, 초기화를 배열의 길이보다 5 큰 값으로 하여 최소값으로 업데이트가 제대로 이루어질 수 있도록 하였다.</p>
<p>가능한 모든 구간합을 확인하기 위해 반복문을 <code>u &lt;= N</code>일 때까지 반복한다. 누적합을 통해 <code>(l,u]</code>의 구간합을 구한다. 그런 다음 그 구간합이 S보다 크거나 같다면 값을 줄이기 위해 왼쪽 포인터를 앞으로 이동시킨다. 만약 반대로 구간합이 S보다 작다면, 값을 늘리기 위해 오른쪽 포인터를 앞으로 이동시킨다. </p>
<pre><code class="language-java">    int l = 0;
    int u = 1;
    int minLength = MAX_LENGTH;
    while (u &lt;= N) {
        int sectionSum = prefixSum[u]-prefixSum[l];
        if (sectionSum &gt;= S) {
            minLength = Math.min(minLength, u-l);
            l++;
        }
        else u++;
    }
</code></pre>
<p>반복문을 빠져나왔다면 결과를 출력한다. 만약 <code>minLength == MAX_LENGTH</code>라면 한 번도 구간합의 값이 S보다 크거나 같지 않았던 것이므로 문제의 요구에 따라 0을 출력한다. 그렇지 않다면 <code>minLength</code>를 출력해 가능한 최소 길이를 출력한다. </p>
<pre><code class="language-java">    System.out.println(minLength == MAX_LENGTH ? 0 : minLength);
}
</code></pre>
<h2>전체 코드</h2>
<pre><code class="language-java">import java.util.*;
import java.io.*;

class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    static int MAX_LENGTH = 100005;

    public static void main(String[] args) throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N, S;
        N = Integer.parseInt(st.nextToken());
        S = Integer.parseInt(st.nextToken());

        int[] prefixSum = new int[N+1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i &lt;= N; i++) {
            prefixSum[i] = prefixSum[i-1] + Integer.parseInt(st.nextToken());
        }

        int l = 0;
        int u = 1;
        int minLength = MAX_LENGTH;
        while (u &lt;= N) {
            int sectionSum = prefixSum[u]-prefixSum[l];
            if (sectionSum &gt;= S) {
                minLength = Math.min(minLength, u-l);
                l++;
            }
            else u++;
        }
        System.out.println(minLength == MAX_LENGTH ? 0 : minLength);
    }
}
</code></pre>
<h2>시간복잡도</h2>
<p>투 포인터에서, $u=N$이 되고 $l=N-1$이 되는 최악의 경우를 생각해볼 수 있다. 가령 다음 입력과 같은 경우이다.</p>
<pre><code>10 10000
1 2 3 4 5 6 7 8 9 10000
</code></pre>
<p>즉 최악의 경우 투 포인터는 $O(2N-1) \approx O(N)$ 시간복잡도가 된다. 따라서 이 알고리즘은 BST를 사용한 $O(N \log N)$ 보다 빠르다.</p>

        <script>
          location.href = "/post-view?href=posts%2FPS%2F2026-01-30-%EB%B0%B1%EC%A4%80-1806-%EB%B6%80%EB%B6%84%ED%95%A9.md"
        </script>
      </body>
  

      <html lang="ko">
      <head>
        <title>1043 - ê±°ì§“ë§</title>
        <link rel="canonical" href="http://yuyeol3.github.io/"/>
        <meta charset="utf-8"/>
        <meta name="description" content="ì´ ë¬¸ì œëŠ” ì—¬ëŸ¬ ê°œì˜ íŒŒí‹°ê°€ ìˆê³  ê·¸ íŒŒí‹°ì— ì°¸ì—¬í•˜ëŠ” ì—¬ëŸ¬ ì‚¬ëŒì´ ìˆì„ ë•Œ, ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒì„ í”¼í•˜ì—¬ ê±°ì§“ë§ì„ í•  ìˆ˜ ìˆëŠ” íŒŒí‹°ì˜ ê°œìˆ˜ê°€ ëª‡ ê°œì¸ì§€ ì•Œì•„ë‚´ëŠ” ë¬¸ì œì´ë‹¤.">
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      </head>
      <body style="display : none;">
        
        <h1>1043 - ê±°ì§“ë§</h1>
<p>ì´ ë¬¸ì œëŠ” ì—¬ëŸ¬ ê°œì˜ íŒŒí‹°ê°€ ìˆê³  ê·¸ íŒŒí‹°ì— ì°¸ì—¬í•˜ëŠ” ì—¬ëŸ¬ ì‚¬ëŒì´ ìˆì„ ë•Œ, ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒì„ í”¼í•˜ì—¬ ê±°ì§“ë§ì„ í•  ìˆ˜ ìˆëŠ” íŒŒí‹°ì˜ ê°œìˆ˜ê°€ ëª‡ ê°œì¸ì§€ ì•Œì•„ë‚´ëŠ” ë¬¸ì œì´ë‹¤. </p>
<p>ë¬¸ì œì˜ íŠ¹ì§• ì¤‘ í•˜ë‚˜ëŠ” ë¨¼ì € ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒê³¼ ê°™ì€ íŒŒí‹°ì— ì°¸ì„í•œ ì‚¬ëŒ ë˜í•œ ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒì´ ëœë‹¤ëŠ” ê²ƒì´ë‹¤. ì¦‰ ì§„ì‹¤ì„ ëª¨ë¥´ë˜ ì°¸ì—¬ìë“¤ì´ ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì°¸ì—¬ìë“¤ê³¼ ê°™ì€ íŒŒí‹°ì— ì°¸ì—¬í•˜ê²Œ ë˜ë©´ ì§„ì‹¤ì„ ì•Œê²Œ ë˜ë©°, ê²°êµ­ ê°™ì€ íŒŒí‹°ë¥¼ í†µí•´ ì—°ê²°ë˜ëŠ” ì´ ê´€ê³„ëŠ” ë°˜ì‚¬ì , ì¶”ì´ì , ëŒ€ì¹­ì ì´ë¼ê³  í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì°¸ì—¬ìë“¤ë¼ë¦¬ëŠ” í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ ë¬¶ì„ ìˆ˜ ìˆë‹¤.</p>
<p>ì´ëŸ¬í•œ ìƒí™©ì—ì„œ Union Find ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ë©´ ë¬¸ì œë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ í’€ ìˆ˜ ìˆë‹¤. ì´ ë•Œ Union find ì•Œê³ ë¦¬ì¦˜ì´ë€ ìƒí˜¸ ë°°íƒ€ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì§‘í•©ì„ íš¨ìœ¨ì ìœ¼ë¡œ í‘œí˜„í•˜ê¸° ìœ„í•œ ìë£Œêµ¬ì¡°ì´ë‹¤. union ì—°ì‚°ì€ ë‘ ì„œë¡œì†Œ ì§‘í•©ì„ í•©ì¹˜ëŠ” ì—°ì‚°ì´ê³ , find ì—°ì‚°ì€ ì–´ë–¤ ì§‘í•©ì˜ ì›ì†Œë¥¼ ì…ë ¥ë°›ì•„ ê·¸ ì›ì†Œê°€ ì†í•œ ì§‘í•©ì˜ ëŒ€í‘œê°’ì„ ë°˜í™˜í•´ì£¼ëŠ” ì—°ì‚°ì´ë‹¤. </p>
<p>í…œí”Œë¦¿ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.</p>
<pre><code class="language-java">class UnionFind {
    static int[] parent;
    static int[] rank;
    static void initialize(int n) {
        parent = new int[n+1];
        rank = new int[n+1];
        for (int i = 0; i &lt;= n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    static int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

    static void union(int a, int b) {
        int rootA = find(a);
        int rootB = find(b);

        if (rootA == rootB) return;

        if (rank[rootB] &gt; rank[rootA]) {
            int tmp = rootA;
            rootA = rootB;
            rootB = tmp;
        }
        parent[rootB] = rootA;

        if (rank[rootA] == rank[rootB])
            rank[rootA] += 1;
    }
}
</code></pre>
<p><a href="https://www.acmicpc.net/problem/1043">ğŸ”— ë¬¸ì œ ë§í¬</a></p>
<h2>ì½”ë“œ</h2>
<p>ë¨¼ì € Union-Find ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ í…œí”Œë¦¿ ì½”ë“œë¥¼ ì‘ì„±í•œë‹¤. </p>
<pre><code class="language-java">    static int[] parent;
    static int[] rank;
    static void initialize(int n) {
        parent = new int[n+1];
        rank = new int[n+1];
        for (int i = 0; i &lt;= n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    static int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

    static void union(int a, int b) {
        int rootA = find(a);
        int rootB = find(b);

        if (rootA == rootB) return;

        // ë†’ì´ê°€ ë†’ì€ ìª½ì´ rootA ì— ìˆë„ë¡ ë³´ì¥
        if (rank[rootB] &gt; rank[rootA]) {
            int tmp = rootA;
            rootA = rootB;
            rootB = tmp;
        }

        parent[rootB] = rootA;
        
        // ë†’ì´ê°€ ê°™ìœ¼ë©´ Aì˜ ë†’ì´ ì¦ê°€í•¨
        if (rank[rootA] == rank[rootB])
            rank[rootA] += 1;
    }
</code></pre>
<p>ë‹¤ìŒìœ¼ë¡œ N, Mì„ ì…ë ¥ë°›ê³  Union-Findë¥¼ ì´ˆê¸°í™”í•œë‹¤.</p>
<pre><code class="language-java">public static void main(String[] args) throws IOException{
    StringTokenizer st = new StringTokenizer(br.readLine());
    int N, M;
    N = Integer.parseInt(st.nextToken());
    M = Integer.parseInt(st.nextToken());

    initialize(N);
</code></pre>
<p>ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒë“¤ì„ ì…ë ¥ë°›ëŠ”ë‹¤. Union ì—°ì‚°ì„ ì´ìš©í•´ ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒë“¤ ëª¨ë‘ë¥¼ ê°™ì€ ì§‘í•©ìœ¼ë¡œ ì—°ê²°í•œë‹¤. í•œí¸ ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒë“¤ì´ í•œ ëª…ë„ ì—†ë‹¤ë©´ ì–´ëŠ íŒŒí‹°ì—ì„œë“  ê±°ì§“ë§ì„ í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì •ë‹µì€ í•­ìƒ Mì´ë‹¤. ë”°ë¼ì„œ <code>K == 0</code>ì´ë©´ <code>M</code>ì„ ì¶œë ¥í•˜ê³  í”„ë¡œê·¸ë¨ì„ ì¦‰ì‹œ ì¢…ë£Œí•œë‹¤.</p>
<pre><code class="language-java">    st = new StringTokenizer(br.readLine());
    int K = Integer.parseInt(st.nextToken());

    if (K == 0) {
        bw.write(M + &quot;\n&quot;);
        bw.flush();
        return;
    }

    int knowsTruth = Integer.parseInt(st.nextToken());
    for (int i = 0; i &lt; K-1; i++)
        union(knowsTruth, Integer.parseInt(st.nextToken()));
</code></pre>
<p>ì´ì œ íŒŒí‹°ì™€ ê´€ë ¨í•œ ì •ë³´ë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤. ë¨¼ì € <code>partyCrits</code> ë°°ì—´ì„ ì„ ì–¸í•˜ì—¬ í•´ë‹¹ íŒŒí‹°ì— ì°¸ì—¬í•˜ëŠ” ì°¸ê°€ìì˜ ëŒ€í‘œ ì›ì†Œë“¤ì„ ì €ì¥í•  ë°°ì—´ì„ ì„ ì–¸í•œë‹¤. ê·¸ëŸ° ë‹¤ìŒ ê° íŒŒí‹°ë³„ ì°¸ì—¬ì¸ì›ê³¼ ì°¸ì—¬í•˜ëŠ” ì‚¬ëŒ ë²ˆí˜¸ë¥¼ ì…ë ¥ë°›ì•„ ì¦‰ì‹œ íŒŒí‹°ì˜ ëŒ€í‘œ ì›ì†Œì™€ Union ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤. ì´ ë•Œ íŒŒí‹°ì— ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒì´ ì°¸ì—¬í•œë‹¤ë©´ ê·¸ íŒŒí‹°ì˜ ëª¨ë“  ì°¸ì—¬ìë“¤ì€ ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì°¸ì—¬ìë“¤ì˜ ì§‘í•©ì— ì†í•˜ê²Œ ë  ê²ƒì´ë‹¤.</p>
<pre><code class="language-java">    int[] partyCrits = new int[M];
    for (int i = 0; i &lt; M; i++) {
        st = new StringTokenizer(br.readLine());
        int partyNum = Integer.parseInt(st.nextToken());
        partyCrits[i] = Integer.parseInt(st.nextToken());
        
        for (int j = 0; j &lt; partyNum-1; j++) {
            int participantNum = Integer.parseInt(st.nextToken());
            union(partyCrits[i], participantNum);
        }
    }
</code></pre>
<p>ìµœì¢…ì ìœ¼ë¡œ ê±°ì§“ë§ì„ ë§í•  ìˆ˜ ìˆëŠ” íŒŒí‹°ì˜ ê°œìˆ˜ë¥¼ êµ¬í•œë‹¤. íŒŒí‹°ì˜ ëŒ€í‘œ ì°¸ì—¬ìê°€ ì†í•œ ì§‘í•©ì´ ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì°¸ì—¬ìë“¤ì˜ ì§‘í•©ê³¼ ê°™ë‹¤ë©´ ê·¸ íŒŒí‹°ì—ëŠ” ì§„ì‹¤ì„ ì•Œê³  ìˆëŠ” ì‚¬ëŒì´ ìˆë‹¤ëŠ” ëœ»ì´ë¯€ë¡œ ê±°ì§“ë§ì„ í•  ìˆ˜ê°€ ì—†ë‹¤. ë”°ë¼ì„œ íŒŒí‹°ì˜ ê° ëŒ€í‘œ ì°¸ì—¬ìì— ëŒ€í•´ ì§‘í•©ì„ í™•ì¸í•˜ê³  ê²°ê³¼ë¥¼ êµ¬í•´ ì¶œë ¥í•œë‹¤.</p>
<pre><code class="language-java">    int result = 0;
    int truthRoot = find(knowsTruth);
    for (int crit : partyCrits) {
        if (find(crit) != truthRoot) 
            result++;
    }

    bw.write(result + &quot;\n&quot;);
    bw.flush();
</code></pre>
<h2>ì „ì²´ ì½”ë“œ</h2>
<pre><code class="language-java">import java.util.*;
import java.io.*;

class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    static int[] parent;
    static int[] rank;
    static void initialize(int n) {
        parent = new int[n+1];
        rank = new int[n+1];
        for (int i = 0; i &lt;= n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    static int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

    static void union(int a, int b) {
        int rootA = find(a);
        int rootB = find(b);

        if (rootA == rootB) return;

        if (rank[rootB] &gt; rank[rootA]) {
            int tmp = rootA;
            rootA = rootB;
            rootB = tmp;
        }

        parent[rootB] = rootA;

        if (rank[rootA] == rank[rootB])
            rank[rootA] += 1;
    }


    public static void main(String[] args) throws IOException{
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N, M;
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        initialize(N);


        st = new StringTokenizer(br.readLine());
        int K = Integer.parseInt(st.nextToken());

        if (K == 0) {
            bw.write(M + &quot;\n&quot;);
            bw.flush();
            return;
        }

        int knowsTruth = Integer.parseInt(st.nextToken());
        // O(K)
        for (int i = 0; i &lt; K-1; i++)
            union(knowsTruth, Integer.parseInt(st.nextToken()));
        
        
        int[] partyCrits = new int[M];
        // O(M * #participants)
        for (int i = 0; i &lt; M; i++) {
            st = new StringTokenizer(br.readLine());
            int partyNum = Integer.parseInt(st.nextToken());
            partyCrits[i] = Integer.parseInt(st.nextToken());
            
            for (int j = 0; j &lt; partyNum-1; j++) {
                int participantNum = Integer.parseInt(st.nextToken());
                union(partyCrits[i], participantNum);
            }
        }

        int result = 0;
        int truthRoot = find(knowsTruth);
        // O(M * Î±(N)) 
        for (int crit : partyCrits) {
            if (find(crit) != truthRoot) 
                result++;
        }

        bw.write(result + &quot;\n&quot;);
        bw.flush();
    }    
}
</code></pre>
<h2>ì‹œê°„ë³µì¡ë„</h2>
<p>Union-Find ì‹œê°„ë³µì¡ë„ëŠ” $O(M \times \alpha(N))$ ìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆìœ¼ë©° $M$ì€ ì—°ì‚°ì˜ íšŸìˆ˜, $N$ì€ ì›ì†Œì˜ ê°œìˆ˜ë¥¼ ëœ»í•œë‹¤.</p>
<p>ì´ë¥¼ í†µí•´ ë„ì¶œí•´ ë³´ë©´, ê° ë£¨í”„ë³„ ì‹œê°„ë³µì¡ë„ë¥¼ ë”í•˜ë©´ $O(K \times \alpha(N)) + O(\sum(\text{#participants}) \times \alpha(N)) + O(M \times \alpha(N))$ ì´ë‹¤. ë”°ë¼ì„œ ì´ ì½”ë“œì˜ ì‹œê°„ë³µì¡ë„ëŠ” $O((K + \sum(\text{#participants}) + M)\alpha(N))$ ì´ë‹¤. ìµœì•…ì˜ ê²½ìš° ëŒ€ëµ $50 + 2500 +50 = 2600 \le 2\text{ì–µ}$ ì´ë¯€ë¡œ ë¬¸ì œì—†ì´ í†µê³¼í•  ìˆ˜ ìˆë‹¤.</p>

        <script>
          location.href = "/post-view?href=posts%2FPS%2F2026-01-12-%EB%B0%B1%EC%A4%80-1043-%EA%B1%B0%EC%A7%93%EB%A7%90.md"
        </script>
      </body>
  